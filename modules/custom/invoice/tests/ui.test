<?php

/**
 * @file
 * UI tests for the Invoice module.
 */

module_load_include('inc', 'test_traits', 'base');
module_load_include('inc', 'test_traits', 'business');
module_load_include('inc', 'test_traits', 'client');
module_load_include('inc', 'test_traits', 'invoice');
module_load_include('inc', 'test_traits', 'line_item');

class InvoiceUITestCase extends InvoicingIntegrationTestCase {

  use BaseTestHelper;
  use BusinessTestHelper;
  use ClientTestHelper;
  use InvoiceTestHelper;
  use LineItemTestHelper;

  /**
   * {@inheritdoc}
   */
  protected $usersToCreate = array('business owner');

  /**
   * A test client.
   *
   * @var Client
   */
  protected $client;

  /**
   * A test product.
   *
   * @var LineItem
   */
  protected $product;

  /**
   * A test service.
   *
   * @var LineItem
   */
  protected $service;

  /**
   * Returns test case metadata.
   */
  public static function getInfo() {
    return array(
      'name' => 'UI test',
      'description' => 'Tests the managing of invoices through the user interface.',
      'group' => 'Invoicing - Invoice',
    );
  }

  /**
   * {@inheritdoc}
   */
  protected function setUp() {
    parent::setup();

    // Log in the business owner.
    $this->drupalLogin($this->users['business owner']);

    // Create a client.
    $this->client = $this->createUiClient();

    // Create a line item of each type so they can be referenced in invoices.
    $this->product = $this->createLineItem('product');
    $this->product->save();
    $this->service = $this->createLineItem('service');
    $this->service->save();
  }

  /**
   * Tests the invoice form.
   */
  public function testInvoiceForm() {
    // Check that the database table exists and is empty.
    $this->assertTrue(db_table_exists('invoice'), 'The invoice database table exists.');
    $this->assertInvoiceTableEmpty('The invoice database is initially empty.');

    // Click on the "Add existing entity" button to display the autocomplete
    // field, so we can check if it will be marked as required.
    // @todo Rework this once we have the unified autocomplete field.
    // @see https://github.com/pfrenssen/invoicing/issues/20
    $this->drupalGet('invoice/add');
    $button_element = $this->xpath('//input[@id = "edit-field-invoice-client-und-actions-ief-add-existing"]');
    $this->drupalPostAJAX(NULL, array(), (string) $button_element[0]['name']);

    // Check that error messages are displayed about required fields when
    // creating a new invoice.
    $this->drupalPost(NULL, array(), t('Save'));
    $required_fields = array(
      'field_invoice_client[und][form][entity_id]' => t('Client'),
      'field_invoice_number[und][0][value]' => t('Invoice number'),
    );
    $messages = array(
      'error' => array(
        t('!name field is required.', array('!name' => t('Client'))),
        t('The selected @label is not valid.', array('@label' => t('client'))),
        t('!name field is required.', array('!name' => t('Invoice number'))),
      ),
    );
    $this->assertRequiredFieldMessages($required_fields, $messages);

    // Fill in all the fields and check if they are saved correctly.
    $values = $this->randomInvoiceValues();
    $values['field_invoice_client'] = $this->client;
    $invoice = $this->createUiInvoice($values);
    $messages = array('status' => array(t('New invoice has been added.')));
    $this->assertStatusMessages($messages, 'A message is shown informing the user that the invoice has been added.');
    $this->assertInvoiceTableNotEmpty('The invoice database table is no longer empty after creating a invoice.');
    $this->assertInvoiceProperties($invoice, $values, 'The invoice has been correctly saved to the database.');
    $this->assertUrl('invoices', array(), 'The user is redirected to the invoice overview after creating a new invoice.');

    // Check that the form fields have correct values when the invoice is
    // edited.
    $this->drupalGet('invoice/' . $invoice->iid . '/edit');
    $form_values = $this->convertInvoiceValuesToFormPostValues($values);

    // The entity reference fields (client name, products and services) are not
    // shown as fields but as inline tables. Test these separately.
    $this->assertXPathElements('//td[contains(@class, "inline-entity-form-client-name") and text() = :name]', 1, array(':name' => $this->client->name), 'The client name is shown in an inline table.');
    unset($form_values['field_invoice_client[und][form][entity_id]']);
    $this->assertXPathElements('//td[contains(@class, "inline-entity-form-line_item-lid") and text() = :lid]', 1, array(':lid' => $this->product->identifier()), 'The product id is shown in an inline table.');
    unset($form_values['field_invoice_products[und][form][entity_id]']);
    $this->assertXPathElements('//td[contains(@class, "inline-entity-form-line_item-lid") and text() = :lid]', 1, array(':lid' => $this->service->identifier()), 'The service id is shown in an inline table.');
    unset($form_values['field_invoice_services[und][form][entity_id]']);

    // Test the remaining values.
    foreach ($form_values as $name => $value) {
      $this->assertFieldByName($name, $value, format_string('When editing an existing invoice the %name field has the right value.', array('%name' => $name)));
    }

    // Change the values and check that the entity is correctly updated.
    $new_values = $this->randomInvoiceValues();

    // Disregard the entity reference fields (client name, products and
    // services), these are currently displayed as inline tables. They will be
    // reworked in the future.
    // @todo Test this when issue #20 is in.
    // @see https://github.com/pfrenssen/invoicing/issues/20
    $new_values['field_invoice_client'] = $values['field_invoice_client'];
    $new_values['field_invoice_products'] = $values['field_invoice_products'];
    $new_values['field_invoice_services'] = $values['field_invoice_services'];
    $edit = $this->convertInvoiceValuesToFormPostValues($new_values);
    unset($edit['field_invoice_client[und][form][entity_id]']);
    unset($edit['field_invoice_products[und][form][entity_id]']);
    unset($edit['field_invoice_services[und][form][entity_id]']);

    $this->drupalPost('invoice/' . $invoice->iid . '/edit', $edit, t('Save'));
    $invoice = invoice_load($invoice->iid, TRUE);
    $messages = array('status' => array(t('The changes have been saved.', array('%invoice_number' => $values['field_invoice_number']))));
    $this->assertStatusMessages($messages, 'A message is shown informing the user that the invoice has been edited.');
    $this->assertInvoiceProperties($invoice, $new_values, 'The updated invoice has been correctly saved to the database.');
    $this->assertUrl('invoices', array(), 'The user is redirected to the invoice overview after editing an invoice.');

    // Check that the user is redirected to the confirmation page when clicking
    // the 'Delete' button on the invoice edit page.
    $this->drupalPost('invoice/' . $invoice->iid . '/edit', array(), t('Delete'));
    $this->assertUrl('invoice/' . $invoice->iid . '/delete', array(), 'The user is redirected to the confirmation form when clicking the "Delete" button in the invoice edit form.');
    $this->assertRaw(t('Are you sure you want to delete the invoice?'));
    $this->assertRaw(t('This action cannot be undone.'), 'The disclaimer is shown when deleting an invoice.');

    // Check that the invoice can be deleted.
    $this->drupalPost('invoice/' . $invoice->iid . '/delete', array(), t('Delete'));
    $messages = array('status' => array(t('The invoice has been deleted.')));
    $this->assertStatusMessages($messages, 'A message is shown informing the user that the invoice has been deleted.');
    $this->assertInvoiceTableEmpty('The invoice database is empty after the invoice has been deleted.');
    $this->assertUrl('invoices', array(), 'The user is redirected to the invoice overview after deleting an invoice.');
  }

  /**
   * Tests setting the 'paid' option on the invoice status.
   */
  public function testInvoicePaid() {
    // Create an invoice using random values.
    $invoice = $this->createUiInvoice();

    // Edit the invoice and set the 'status' field to 'paid'. Save the changes.
    $edit = array('field_invoice_status[und]' => 'paid');
    $this->drupalPost('invoice/' . $invoice->iid . '/edit', $edit, t('Save'));

    // Check status message after saving.
    $messages = array('status' => array(t('The changes have been saved.')));
    $this->assertStatusMessages($messages, 'A message is shown informing the user that the invoice has been edited.');

    // Check that the status is saved correctly.
    $invoice = invoice_load($invoice->iid, TRUE);
    $values = array('field_invoice_status' => 'paid');
    $this->assertInvoiceProperties($invoice, $values, 'The updated invoice has been correctly saved to the database.');

    // Check target Url after redirection.
    $this->assertUrl('invoices', array(), 'The user is redirected to the invoice overview after editing an invoice.');
  }

  /**
   * Tests line item tax rate forms on the invoice.
   */
  public function testInvoiceLineItemTaxRate() {
    // Add some tax rates.
    $tax_rates_added = array();
    $first_digit = rand(1, 9);
    for ($i = 0; $i < 4; $i++) {
      $tax_rates_added[$i] = $this->createUiTaxRate(array(
        'name' => "test rate {$i}",
        'rate' => "{$first_digit}{$i}.00",
      ));
    }

    // Go to add invoice page.
    $this->drupalGet('invoice/add');

    // Verify that the tax field is an autocomplete field.
    $dropdown_results = $this->drupalGet('settings/tax-rates/autocomplete/' . $first_digit);

    // Verify that the autocomplete field shows the tax rates created.
    $dropdown_tax_rates = json_decode($dropdown_results, TRUE);
    $n_results  = count($dropdown_tax_rates);
    $actual_tax_rate_values = array();
    $expected_tax_rate_values = array();
    $dropdown_tax_rates_copy = $dropdown_tax_rates;
    for ($i = 0; $i < $n_results; $i++) {
      array_push($actual_tax_rate_values, array_pop($dropdown_tax_rates_copy));
      array_push($expected_tax_rate_values, $tax_rates_added[$i]->rate);
    }
    $diff = array_diff($actual_tax_rate_values, $expected_tax_rate_values);
    $this->assertFalse($diff, 'Autocomplete field shows correctly the tax rates created.');

    // Create a new service and product choosing a dropdown tax rate value.
    $random_selected_tax_value = array_rand($dropdown_tax_rates);
    $line_item_values = array('field_line_item_tax' => $random_selected_tax_value);
    $service = $this->createLineItem('service', $line_item_values);
    $product = $this->createLineItem('product', $line_item_values);
    $service->save();
    $product->save();

    // Load saved service and product and verify that all tax rates were saved
    // correctly.
    $service = line_item_load($service->lid);
    $product = line_item_load($product->lid);
    $this->assertEntityProperties('line_item', $service, $line_item_values, 'Service has been correctly saved.');
    $this->assertEntityProperties('line_item', $product, $line_item_values, 'Product has been correctly saved.');

    // Generate random invoice values.
    $new_values = $this->randomInvoiceValues();

    // Add the new service and product to the invoice values.
    $new_values['field_invoice_services'][0] = $service;
    $new_values['field_invoice_products'][0] = $product;

    // Create and save the new invoice.
    $invoice = $this->createUiInvoice($new_values);

    // Load the invoice and verify that all tax rates were saved correctly.
    $invoice = invoice_load($invoice->iid, TRUE);
    $this->assertInvoiceProperties($invoice, $new_values, 'The invoice tax rates have been correctly saved to the database.');
  }
}
